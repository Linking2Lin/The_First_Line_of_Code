# C1 概述
Android系统架构：
* Linux内核层：提供硬件底层驱动
* 系统运行库层：一些C/C++库为提供特性资产，还有Android运行时库（Android Runtime），主要包括ART运行环境（5.0之前为Dalvik虚拟机）
* 应用框架层：提供构建应用程序时用到的各种API
* 应用层：所有安装在手机中的应用程序，包括系统应用

Android程序的设计讲究逻辑和视图分离，因此不推荐在Activity中直接编写界面，通常是在布局文件中编写界面，然后在Activity中将布局文件引入进来   
图片资源一般放在drawable-xxhdpi即可，这是主流的设备分辨率目录       

# C2 Kotlin基础
### 变量：
Kotlin通过一个特殊的编译器将代码转为class文件然后交由JVM虚拟机运行
Kotlin抛弃了基本数据类型，全部使用了对象数据类型
尽量将变量申明为val，val只是对象引用不可变，对象本身的改变并不限制
### 函数：
函数格式：`fun 函数名（参数列表）：返回值类型{函数体}`   
当函数体内只有一行代码时，可以将{}省略，然后用=将函数声明与函数体进行连接（同时可以省略返回值类型，返回值类型会被自动推导）   
### 逻辑控制：
if：与Java基本一样，只是增加了返回值的功能，条件分支的最后一行将会被作为返回值返回
when：类似switch，格式：when（参数）{ 匹配值 ->{执行逻辑} }，同样具有返回值的功能，也可以用来进行类型匹配，也可以不带参数，将判断的表达式完整地写在when的结构体中
### 循环：
while：与Java一样
for：for-i被抛弃，for-each被加强
* 关键字：..：闭区间，until：左闭右开，step：在循环内递增的增量，downTo，降序闭区间，
### OO
* 在class前加上open关键字，使类可以被继承    
* 继承方式:`class A:superclass()`
* 主构造函数：每个类默认存在一个不带参数的主构造函数，也可以指定参数，没有结构体，直接定义在类名的后面即可     
* 主构造函数的逻辑：写在init代码块里即可
* 子类的构造函数必须调用父类的构造函数，继承时父类名后的括号内没内容的话表明的就是调用父类的无参构造函数    
* 次构造函数：一般情况下通过给主构造函数设立默认值的方式可以避免使用次构造函数，次构造函数必须调用主构造函数，次构造函数使用`constructor`关键字来定义
* 接口：实现接口时不需要加（），而且允许接口内的函数有默认实现（JDK1.8后Java也支持），子类不实现默认实现的方法的话，该方法会使用默认逻辑
* 修饰符：抛弃default，加上了internal（同一模块中的类可见），默认使用的是public
* 数据类：data class，自动加上toString等方法
* 单例类：class关键字改为object即可，调用方式类似与Java静态方法的调用
### Lambda编程：
Lambda表达式结构：`{参数名1：参数类型，参数名2：参数类型 ->函数体}`,最后一行代码会自动作为表达式的返回值    
参数列表中只有一个参数时，可以不用声明参数名，直接使用`it`来代替
kotlin完全舍弃new关键字，因此创建匿名类实例的时候需要使用`object：`关键字  
### 空指针检查：
kotlin将空指针异常的检查提前到编译时期    
如果变量或参数可为空，则需在声明时在类名后加上可空声明符`?`    
判空辅助工具：
* `?.`：当对象不为空正常调用相应的方法，为空则什么都不做
* `?:`：左右两边都接收一个表达式，左边表达式结果不为空就返回左边的结果，否则返回右边的结果
### 函数参数
* 参数默认值尽量配合键值对传参的形式来使用    

#回调：回调函数的简称，指一段以参数形式传递给其他代码的可执行代码，该函数编写方是A，但是调用方是B，A调用了B的一个函数F1，调用时将回调函数F2作为参数传递给F1，然后B执行F1，执行完成后将结果传给F2，然后执行F2

# C3 Activity活动 && Intent意图
## Activity：
Activity的启动和组合方式是Android平台应用模型的基本组成部分，Android系统通过调用各Activity实例中对应各生命周期的回调方法来运行Activity实例中的代码    
Activity可以看作Android应用重新的最小单元，一个完整的应用程序通常包含多个Activity，其中有一个为主Activity，通常情况下是用户启动应用的第一个界面，但用户与应用的互动开始点可以是其他Activity，应用也可以调用其他应用的某一个Activity，而不是每次都从主Activity启动    

[生命周期](![img.png](img.png))：
* onCreate：Activity第一次被创建时调用，一般用来执行Activity的初始化操作
* onStart：Activity由不可见变为可见时调用
* onResume：准备好与用户进行交互时调用
* onPause：系统准备启动或恢复另一个Activity时调用
* onStop：Activity完全不可见时调用
* onDestroy：Activity被销毁前调用
* onRestart：Activity由停止状态变为运行状态前调用
* onSaveInstanceState：携带Bundle类型的参数，采用键值对的形式来保存数据，该方法会在Activity被回收前调用，而oncreate参数中的Bundle会带有回收前保存的数据       
Activity启动模式，清单文件内指定：
  * standard：默认模式，在栈顶入栈一个新的Activity实例，栈内是否已纯在
  * singleTop：栈顶如果是该Activity的实例，就直接使用，否则重新入栈新的实例
    * singleTask：栈内有已纯在的实例就直接使用并将上面的全部出栈，没有的话再新建实例
    * singleInstance：启用新的返回栈管理该Activity的实例，通常用于与其他程序共享的Activity，这样不同的程序在访问该Activity时，公用同一个返回栈



## Intent:
各组件间进行交互的一种载体
用来启动其他组件的方式通常有两种：
* 显示启动：代码里直接构造，指明意图
* 隐式启动：配合IntentFliter使用，各控件指明响应的意图信息（一个action，多个category，data用来指定响应的数据），代码中构造Intent时只指定信息，系统会通过构造的intent对象里包含的信息，寻找到与信息适配的控件，然后启动         

向其他控件传递数据：
* 使用一系列putExtra（）向下一个组件传递，数据使用键值对形式储存    
* 向上一个Avtivity返回数据：使用registerForActivityResult（API29后，之前使用startActivityForResult，29后弃用）    

## C3 kotlin：
### 标准函数：
* `let`：在对象上调用，将调用对象本身传递进lambda表达式中
* `with`：接收两个参数，第一个为任意类型的对象，第二个为Lambda表达式，该函数会在Lambda表达式中提供第一个参数的上下文，并使用Lambda表达式的最后一行代码作为返回值，常用于连续调用同一对象的多个方法
* `run`：接收一个Lambda参数，在某个对象上调用，在Lambda表达式中提供调用对象的上下文，同样使用最后一行作为返回值返回
* `apply`：接收调用同上，只是返回对象本身，适用于在一段代码内需要对某一对象多次处理的情况
### 静态方法：
使用上，工具类直接使用单例类来干，其他情况下将函数放入`companion object{}`内，实现类似与Java的形式       
也可以使用顶层方法的形式，对于顶层方法：kotlin内直接调用，Java中静态方法形式       


# C4 UI与控件
适配相关：
* px：像素，屏幕上的实际像素点，每个px对应屏幕上的一个点
* dp：也叫dip，设备独立像素，一种基于屏幕密度的抽象单位，在每英寸160像素点的显示器上，1dp=1px，随着屏幕密度的改变，dp与px的换算也会发生改变
* sp：主要用来处理字体的大小,可以根据用户的字体大小首选项进行缩放，即当控件文字大小指定为sp时，当系统文字大小进行更改后，控件文字大小也会随之改变
换算关系：
  px与dp换算：
  px = dp*（density/160），density为屏幕密度，density=dpi/160，dpi（像素密度），表示每英寸距离中有多少个像素点
常用控件：
* TextView：用来在界面上显示一段文本信息
* Button:通过设立监听器，实现点击事件的一个控件，可以看作是带点击功能的TextView
* EditText：允许用户在控件里输入和编辑内容，并可以在程序里对这些内容进行处理
* ImageView：用于在界面上展示图片的一个控件
* ProgressBar：在界面上展示一个进度条
* AlterDialog：在当前界面弹出一个对话框，该对话框置顶于所有界面元素之上，可以屏蔽其他控件的交互能力     
* ListView（推荐使用RecyclerView）：提供一个列表来展示大量数据，比如音乐播放器的歌曲列表，可以通过自定义子项来实现复杂的界面
* RecyclerView：使用流程：

常用布局：
* LinearLayout：线性布局，将包含的控件在线性方向上依次排列
* RelativeLayout：相对布局，通过相对定位的方式让控件出现在布局的任何位置
* FrameLayout：帧布局，所有控件默认摆放在布局左上角，
* ConstraintsLayout：约束布局，通过给控件添加约束条件来确定位置       

## C4 kotlin：
延迟初始化：通常在全局变量上使用，使用`lateinit`关键字，表明该变量的初始化会在稍后进行，这样在其他地方使用时就不需要再进行判空处理，但是一定要确保在使用前进行初始话，否则会抛出异常
密封类：一种受限的类继承结构，该类只能有几种子类去继承它，密封类与其所有子类只能定义在同一文件的顶层位置，可以配合when使用，当when条件传入一个密封类变量为条件时，编译器会强制将该类的全部子类进行处理，否则编译不通过
       
# C5 Fragment碎片 

# C11
### Android网络交互方式：
* HTTP连接：请求-响应模式，客户端向后端发起请求，后端解析请求，然后返回数据，客户端解析返回的数据
* socket连接：长连接模式，相当于在客户端和服务器端建立一条双向通道，
### 网络请求方式
* 使用HttpURLConnection：原生方式
* 使用OkHttp：第三方
### 数据媒介：
* xml：常用解析方式：1.pull解析 2.SAX解析 3.DOM解析
* JSON：常用解析方式：1.JSONObject，原生 2.借用GSON来进行解析
### Retrofit与回调机制
* Retrofit：最常用的网络库，基于OkHttp
* 回调机制：因为网络请求属于耗时操作（虽然一般用不了多长时间），如果在UI线程内执行网络操作，容易引发ANR，所以借用回调机制来规避
### Kotlin协程
* 可以看作轻量级线程
* 协程间的切换可以在编程语言层面上进行，而线程的切换通常需要在系统调度下进行



  